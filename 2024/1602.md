---
title: P7debug经验分享
layout: default
parent: 2024 年
nav_order: 1602
---
# P7debug经验分享
<div class="post-info">
<span>朱城宇</span>
|
<abbr title="2024-12-05T00:03:46.565638+08:00"><time datetime="2024-12-05T00:03:46.565638+08:00">2024-12-05 00:03:46</time></abbr>
|
<span>⭐️ 3</span>
|
<span>💬️ 1</span>
<br>
<div><div class="post-tag">P7</div><div class="post-tag">分享</div><div class="post-tag">测试</div></div>
</div>

<div id="reply-6174" class="reply reply-l0">
<div class="reply-header">
<span>朱城宇</span>
</div>
<div class="reply-text">

本人对于上周每天晚上熬夜调试P7的经历印象太过深刻，所以希望在P7课上强测侥幸通过之后和大家分享一点P7debug的经验和错误。

**以及**本文内容可能比较基础，dalao们可以跳过或者帮我找找错，感谢！

# 1. 对于工具的使用

### 对于仿真工具

1. 如果我们对于目前仿真的波形架构比较满意，想要多次使用的话，可以进行保存，然后在下次使用时直接打开该`.wcfg`文件。

2. 如果我们发现了bug，可以不需要关闭当前仿真，直接回去ISE当中修改代码，修改完保存之后，直接在之前仿真页面点击`re-launch`即可。

3. 对于`SR寄存器`这种数据分段的情况，我们可以把他拖选到仿真窗口之后，点击他左边的三角形把他展开成一位一位的，选中我们要组合的位数，右键点击最下面的`New Virtual Bus`即可把他们合成为一个新的信号整体，如下图所示
![屏幕截图 20241204 203554.png](/assets/cscore-image/23371543/a4f43f42-f124-40ca-9e4d-d2f7971391fa/屏幕截图_2024-12-04_203554.png)
4. 对于新的信号或者以往的信号，我们都可以双击修改它的名称，更有利于我们debug时的清晰思路。同时对于关键信号，我们可以适当设置`Signal Color`进行标记。

5. 仿真的时候如果波形图未加载完，可以点击中间上方蓝色三角形一直跑，直到你点暂停。也可以点他右边那个带沙漏的三角形，一次只多跑一点，这样波形图更好找。

### 对于MARS

1. 首先，如果你想保证正确性，请使用课程组Mars，对于输出部分可以找P7已经过关的同学对拍。其次，课程组Mars由于和多周期CPU原理不同，在计时器方面可能有所不同，但是不用纠结，保证不会因此出错。（具体可以看我在P7答题贴当中的提问）
2. Mars的相关设置：应当注意勾选`settings`中的`Delayed Branching`和`Exception for Course`，在`Memory Configuration`当中勾选`Compact,large Text`
3. 在导出机器码的时候，需要将中间填满`nop`指令到`0x417c`，可以自己搓一个生成`nop`的c程序，也可以无脑复制，不用管`nop`多了，到最后编译的时候，如果`nop`多了，Mars会报错显示`PC值0x4180已经被某某行占用`，这个时候再把`nop`删到那一行就可以了（前提是你使用了`.ktext 0x4180`）



# 2.异常中断错误点总结

P7中的错误点实在太多太多，到现在我勉强通过P7的课上强测依旧无法保证已经注意到所有的P7错误点以及我的CPU的正确性，所以我将写下我所发现和犯过的一些错误点，希望对大家有所帮助，也是抛砖引玉，希望大家一起补充，一起改进，一起过关。

- 先谈一谈我的错误归纳思路：首先按照P7教程当中的错误类型进行**一一构造样例**，保证不重不漏（即所有异常中断都是单独看他们的行为和处理）；然后考虑异常和中断之间的相互影响关系，使异常和中断进行交互；再考虑正常指令和异常中断之间的交互，保证达到**精确异常**的效果；接着考虑**新加指令**作为指令的行为是否正确（例如阻塞转发等等），以及他们在异常中断中的**特殊行为和交互**；最后就是**收集情报**，多看看别人错在哪里，收纳总结。

在以上操作之后，我归纳了如下的测试点并且写出样例构造方法：（**我采用这种to do形的罗列方式**，~~但是好像在这上面语法不支持~~，在保证正确后就给他打上勾，保证不重不漏，而在下面的罗列中，**我将我的测试代码中能够检测的问题打√，我没有实现检测的留白！！！**）

- [x] lw取数地址未字对齐——构造取数地址未字对齐的lw指令（4）
- [x] lh取数未半字对齐——构造取数地址未半字对齐的lh指令（4）
- [x] lh、lb取Timer寄存器的值（4）
- [x] load类指令计算地址加法溢出——分别构造sw、sh、sb加法溢出（4）
- [x] load类指令取数地址越界——分别构造sw、sh、sb取数地址越界（4）
- [x] sw取数地址未字对齐——构造存数地址未字对齐的sw指令（5）
- [x] sh取数未半字对齐——构造存数地址未半字对齐的sh指令（5）
- [x] sh、sb存Timer寄存器的值（5）
- [x] store类指令计算地址加法溢出——分别构造sw、sh、sb加法溢出（5）
- [x] store类指令取数地址越界——分别构造sw、sh、sb取数地址越界（5）
- [x] store类指令向计时器的 Count 寄存器存值（只需要测试lw即可）（5）
- [x] 系统调用——syscall指令（8）
- [x] 未知指令——胡乱写机器码（10）
- [x] 溢出异常——构造add、addi、sub的溢出指令  （12）

- [x] pc地址未字对齐——使用jr指令跳转到未字对齐的pc（4）
- [x] pc地址越界——使用jr指令跳转到越界的pc（4）

异常处理是否正确：

- [x] 正好处于E级的乘除法指令是否开始——异常后面紧跟乘除法
- [x] 正好处于E级的mthi与mtlo是否写入——异常后面紧跟mthi\mtlo
- [x] 已经开始的乘除法是否未受影响——乘除法后面紧跟异常
- [x] load、store错误后是否仍然对DM进行了写入
- [x] RegWrite指令错误后是否仍然对GRF进行了写入
- [x] 延迟槽指令出错时是否正确存入EPC——在异常处理程序中判断EPC是否正确
- [x] 跳转指令未跳转（不符合条件）时是否正确识别延迟槽指令并存入正确的EPC——在异常处理程序中判断EPC是否正确——设置不跳转的beq指令，并且让延迟槽出错
- [x] 发生取指异常或RI后是否将指令设置为nop——请根据波形图查看
- [x] 跳转到不对齐地址时，EPC是否正确——使用jr指令跳转到不对齐地址
- [x] 连续错误指令发生时是否识别最先发生错误指令——连续设置错误即可
- [x] 中断和异常同时发生时是否先相应中断并且接下来正常处理异常——将错误指令PC设置为中断目标PC
- [x] 阻塞过程中发生异常是否正确处理——使用跳转指令来阻塞较为简单
- [x] 阻塞过程中发生中断是否正确处理——使用跳转指令来阻塞较为简单
- [x] eret后的指令是否被执行——在eret后设置一个写入指令


针对中断：

- [x] 外部中断——使用tb文件生成
- [x] Timer寄存器模式1中断——写入计时器使能和计数周期数


新的转发路径：

- [x] mtc0对eret的转发是否正确——mtc0后一个或两个周期设置为eret
- [x] 其他指令对mtc0的转发是否正确

其他：

- [x] 宏观PC在出现阻塞、Req、eret时是否正确
- [ ] 延迟槽指令被阻塞时其BD信号是否仍然正确



# 3.测试代码

有了以上的工具准备和错误总结之后，就可以开始~~开开心心~~地debug了。当然，也少不了测试程序的编写，因为我只是一个P7课上强测侥幸过了但是课上指令两个小时没写出来的蒟蒻，上周写P7的时候无人对拍又不会写数据生成器，所以手搓了一百多行异常代码以及处理程序，这份测试程序只考虑了一部分情况，主要是为了抛砖引玉以及一点启发作用。我会放在最后，**但是还是希望大家能够自己编写或者借鉴着编写属于自己的测试代码，我觉得这其实是P7一个非常重要的过程**（而且写着挺好玩的）。其次，我的代码可修改性比较差，**请不要进行指令的增删**，可能会出现问题。



# 4.走投无路

如果还是无法找到错误或者担心有错，秉持着量大砖飞的原则，实在走投无路推荐大家**妥善**使用cokiller，多测个几千几万行总没有坏处。

**但是**，据我使用的情况来看，不知道是不是我使用方式有问题，在生成P7数据的时候，会出现几个错误：

- 很多`jal`指令后面会缺少`nop`延迟槽，大家可以Ctrl+F找一下，然后手动加上延迟槽。
- 指令很可能跑不完就会进一个奇怪的死循环，我多次使用后感觉大概是在`0x3990~0x399c`之间，只取前面的仿真结果即可。

# 5

祝愿大家都能顺利AKP7！也祝自己下次能够做出课上指令，AKP7（悲）





```mips
.text
    # 允许外部中断，Timer中断
    ori $t0, $0, 0x1c01
    mtc0 $t0, $12
    # 请在宏观PC为30c0和30d0的时候设置两次中断
    
    #lw取数地址未字对齐
    addi $t1 $0 0x3333
    sw $t1 0($0)
    lw $t1 3($0)
    
    #lh取数未半字对齐
    lh $t1 3($0)
    
    #lh、lb取Timer寄存器的值
    lh $t1 0x7F00($0)
    lb $t2 0x7F02($0)
    
    #load类指令计算地址加法溢出
    lui $t1 0xf000
    lw $t2 -0x7fff($t1)
    lh $t2 -0x7fff($t1)
    lb $t2 -0x7fff($t1)
    
    #load类指令取数地址越界
    ori $t1 $0 0x7F1C
    lw $t2 0($t1)
    lh $t2 0($t1)
    lb $t2 0($t1)
    
    #sw存数地址未字对齐
    addi $t1 $0 0x4444
    sw $t1 2($0)
    
    #sh存数未半字对齐
    sh $t1 3($0)
    
    #sh、sb存Timer寄存器的值
    sh $t1 0x7F00($0)
    sb $t2 0x7F02($0)
    
    #store类指令计算地址加法溢出
    lui $t1 0xf000
    sw $t2 -0x7fff($0)
    sh $t2 -0x7fff($0)
    sb $t2 -0x7fff($0)
    
    #store类指令存数地址越界
    ori $t1 $0 0x7F0C
    sw $t2 0($t1)
    sh $t2 0($t1)
    sb $t2 0($t1)
    
    #store类指令向计时器的 Count 寄存器存值
    sw $t1 0x7F08($0)
    
    #系统调用
    ori $v0 $0 1
    syscall
    
    #未知指令
    addu $t1 $t2 $t3
    
    #溢出异常
    lui $t1 0x7fff
    lui $t2 0x7fff
    add $t3 $t1 $t2
    lui $t1 0xf000
    addi $t2 $t1 -0x7000
    lui $t1 0x7fff
    lui $t2 0xf000
    sub $t3 $t1 $t2
    
    #正好处于E级的乘除法指令是否开始
    lw $t3 1($0)
    mult $t1 $t2
    
    #已经开始的乘除法是否未受影响
    mult $t1 $t2
    lw $t3 1($0)
    mflo $t4
    
    #正好处于E级的mthi与mtlo是否写入
    lw $t3 1($0)
    mthi $t4
    mfhi $t4
    
    #阻塞的时候发生中断(请在宏观PC为0x30c0的时候中断)
    lw $t1 0($0)
    jal kk1
    nop 
 
kk1:   
    #检测到异常时发生中断(请在宏观PC为0x30d0时发生中断)
    lw $t3 2($0)
    
    #阻塞过程中发生异常
    lw $t3 3($0)
    lw $t1 3($0)
    lw $t2 0($t1)
    
    #测试Timer的中断功能及其响应是否正确、中断优先级是否正确
    ori $t1 $0 9 #设置计时使能和中断屏蔽
    sw $t1 0x7F00($0)
    ori $t1 $0 1 #设置计时数
    sw $t1 0x7F04($0)
    nop
    nop
    lw $t1 2($0)
    nop
    nop
    nop
    nop
    
    #测试mtc0和eret指令的转发、以及清空延迟槽
    ori $t1 $0 0x3120
    mtc0 $t1 $14
    nop
    eret
    ori $t1 $0 0x444
    ori $t1 $0 0x3138
    sw $t1 0($0)
    lw $t2 0($0)
    mtc0 $t2 $14
    eret
    ori $t1 $0 0x444
    
    #延迟槽指令出错时是否正确存入EPC（如果处理不对，会在这两条指令死循环）
    beq $t1 $t1 jump1
    lw $t2 1($0)
jump1:
    
    #跳转到不对齐地址时，EPC是否正确（pc地址未字对齐、越界）
    ori $t1 $0 0x1111
    jr $t1
    nop
    ori $s0 $0 0x4444
    
    #未达到条件跳转时是否正确存入EPC
    beq $0 $t1 jump2
    lw $t2 1($0)
jump2:

    
end:
    beq $0, $0, end
    nop
_bad:
    ori $s2 $0 0x4444
    beq $0, $0, end
    nop
    
## 中间省略很多个nop

.ktext 0x4180
_entry:

_main_handler:
    # 取出 ExcCode
    mfc0 $k0, $13
    ori $k1, $0, 0x7c
    and $k0, $k0, $k1

    # 如果是中断，对$s1寄存器赋值0x222，并且响应中断
    beq $k0, $0, zhongduan
    nop
    #j _error
    beq $0 $0 _error
    nop
    
zhongduan:
    ori $s1 $0 0x222
    mfc0 $t1 $13
    andi $t1 $t1 0x0400
    beq $t1 $0 _waibuzhongduan  #处理外部中断
    nop
    #处理计时器1中断(同时测试对计时器读写是否正常)
    lw $t1 0x7F00($0)
    andi $t1 $t1 0xfff7
    sw $t1 0x7F00($0)
    #j _exception_return
    beq $0 $0 _exception_return
    nop
    
_waibuzhongduan:
    sb $0, 0x7f20($0)
    #j _exception_return
    beq $0 $0 _exception_return
    nop

_error:  
    #判断是否是pc地址未对齐
    mfc0 $t1 $14
    ori $t2 $0 4
    div $t1 $t2
    mfhi $t1 
    beq $t1 $0 _other_error #其他错误
    nop
    mfc0 $t1 $14
    ori $t2 $0 0x1111
    bne $t1 $t2 _bad #如果出错会写入0x4444
    nop
    ori $t1 $0 0x3150 #注意这个地方是特判，如果修改了之前的代码，会出错
    mtc0 $t1 $14
    beq $0 $0 _exception_return
    nop
    

_other_error:
    #判断是否为延迟槽指令
    mfc0 $t1 $13
    lui $t2 0x8000
    and $t1 $t1 $t2
    beq $0 $t1 _not_BD_error
    nop
    mfc0 $t1 $14
    ori $t2 $0 0x3138
    beq $t1 $t2 _right1
    nop
    ori $t2 $0 0x3150
    beq $t1 $t2 _right2
    nop
    beq $0 $0 _not_BD_error #如果BD的记录error,会陷入死循环
    nop
_right1:
    ori $t1 $0 0x3140
    mtc0 $t1 $14
    beq $0 $0 _exception_return
    nop 
_right2:
    ori $t1 $0 0x3158
    mtc0 $t1 $14
    beq $0 $0 _exception_return
    nop

    # 将 EPC + 4，即处理异常的方法就是跳过当前指令,并且对$s1寄存器赋值0x111
_not_BD_error:
    ori $s1 $0 0x111
    mfc0 $k0, $14
    addi $k0, $k0, 4
    mtc0 $k0, $14
    beq $0 $0 _exception_return
    nop

_exception_return:
    eret
    # 测试eret后的指令是否会被执行
    ori $s0 $0 0x444
```



</div>
<div class="reply-footer">
<abbr title="2024-12-05T00:03:46.580905+08:00"><time datetime="2024-12-05T00:03:46.580905+08:00">2024-12-05 00:03:46</time></abbr>
|
<span>CC BY-NC-SA 4.0</span>
<span class="reply-vote">❤️ 8</span>
</div>
</div>