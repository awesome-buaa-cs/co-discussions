---
title: ❤如何设计一个优雅的CPU（暨E级CP0参考）(P5-P7)
layout: default
parent: 2024 年
nav_order: 1604
---
# ❤如何设计一个优雅的CPU（暨E级CP0参考）(P5-P7)
<div class="post-info">
<span>向滢澔</span>
|
<abbr title="2024-12-05T20:29:04.77147+08:00"><time datetime="2024-12-05T20:29:04.77147+08:00">2024-12-05 20:29:04</time></abbr>
|
<span>⭐️ 5</span>
|
<span>💬️ 1</span>
<br>
<div><div class="post-tag">P5</div><div class="post-tag">P6</div><div class="post-tag">P7</div><div class="post-tag">分享</div><div class="post-tag">Verilog</div></div>
</div>

<div id="reply-6179" class="reply reply-l0">
<div class="reply-header">
<span>向滢澔</span>
</div>
<div class="reply-text">

# 如何设计一个优雅的CPU（P5-P7）
❤以下内容是本人从P5-P7流水线CPU的一个总结，旨在帮助同学们顺利通过所有P，以及给后来的学弟学妹们一个参考，**以及给想把CP0模块放在E级而非M级的同学一个思路与参考**。

> 说在前面：本人的设计尽力采用“优雅”的做法，保证小代码量+符合课程组要求，但是可能和大部分人做法不一样，所以仅供参考，当然我也认为这可以是除了课程组“标准”CPU外的又一种实现吧。

如果你想直接看组件的优雅实现，请跳转到“组件内的优雅设计”一节。

## 一些设计规范
1. 尽力、尽早转发，能转发就转发，绝不阻塞
2. 转发数据来源为流水线寄存器，最多隔了一个MUX，不从大型功能部件后转发
3. （个人强迫症）尽量少编写重复性高的代码，如有则放入`MACROS.v`宏文件里面
4. 尽量不使用`function`，主要是我想提高一点代码易读性，不做过度封装。
5. 高内聚、低耦合。


以上基本就是我设计CPU的时候考虑的东西了，我在P5和P7分别重构了两次CPU，因此代码的史山程度其实还算比较低，再加上前几天一个小bug折磨我半天导致现在对于流水线CPU理解比之前更深刻了，因此写下此文。

## 设计框图总览

![cpu设计.drawio.png](/assets/cscore-image/22375354/3d1f43c9-2144-4c2b-b9f8-1011341327af/cpu设计.drawio.png)

图中蓝色部分为**阻塞、冒险**相关，橙色部分为**异常处理**相关，部分细节接线已省略，各位可以根据自己所在的P进行拆解。

## 工程化方法

连线方面我并没有采用标准的工程化方法，而是直接看图说话，主要是出于效率考虑，这一点不必参考。而关于每个指令的控制信号，我整理出了标准的信号连接表：

![ctrlxignal.PNG](/assets/cscore-image/22375354/cdeb5c5e-595a-4640-907d-845a2c2a3ef3/ctrlxignal.PNG)

这个表格的构建也很简单，每个控制指令对照你的设计图单独分析，包括各种ALUop、MUX选择信号，比如grf需要读出rs信号就填进去，alu需要读入imm16就写进去，最后分析一共多少个信号，给多少位的控制信号，然后按顺序排号即可。

> 这个和课内讲述的工程化方法一致，不再赘述。

## 组件内的优雅设计
以下主要讲解一些我CPU设计比较独特的地方，不一定是最标准的，但是按道理来说比较容易理解，代码量也尽量少。

### PC

设计如下：
```verilog
always @(posedge clk) begin
    if (reset) begin
        /*初始化寄存器部分*/
    end
    else begin
        // 状态更新（内部）
        // 记录上次pc便于stall，并且不stall的时候记录NPC
        last_state <= state;
        if(!stall) next_state <= NPC;
    end
end

always @(negedge clk) begin
    // PC更新（对外）
    // 更新PC_state，stall保持last，不stall就去next
end
    
    // P7还需要接入req信号，来req上升沿的时候立即更新为4180
```

特殊点在于下降沿更新pc，便于稳定写入D级寄存器，同时**分离了 pc更新 和 状态更新**，相比于仅使用上升沿可读性更高，代价是写之前一定要理清楚更新逻辑，不然可能会导致stall时候的错误。P7增加`req`信号的时候也需要注意状态重复更新的问题，但是代码实现很简单。比如可以利用上升沿的`req`更新PC，并且在`clk`下降沿的时候特判不进行重复更新。

需要配合纯组合逻辑的NPC使用，本人的NPC为纯组合逻辑，根据PC输出值计算NPC并回传给PC模块。

### 流水线寄存器
由于后续流水线寄存器中信号过多，可能会导致代码重复多，为了避免这个问题，我们可以采用`wire`输入`reg`输出的方式解决重复编写代码的问题：

```verilog
module W_reg(
    input wire clk, reset,
    input wire [31:0] data_m, 
    output reg [31:0] data_w );

    // 无需定义内部wire

    always @(posedge clk) begin
        if (reset) begin
            data_w <= 32'b0;
        end else begin
            data_w <= data_m;
        end
    end

endmodule
```

可以看出对于每个信号仅需要设置初值+设置下一次值即可，这样就不需要额外在内部定义wire，代码量大大减少。

优雅！❤

### 冒险相关设计

#### 转发框架
冒险设计其实很容易，在P5情况下，新数据产生来源只有以下三处：
- ALU输出（e级）
- DM输出（m级）
- PC+8输出（f级）

分别可以从m、w、d开始转发，也就是Tnew为2、3、0的三处。

这个时候我们考虑E/M/W有个指令，D有个指令，发生了相关性（暂不考虑阻塞），那么可能的转发路径就是E/M/W分别到D级的GRF的两个输出口；同理，若被相关指令在E，那么就是从M/W转发到E的ALU的两个输入口；被相关在M，那么就从W转发到DM的data输入。

因此可以看出，宏观上看只有六条转发路径：E/M/W->D；M/W->E；W->M。

而且每个被转发的地方都有三个数据来源，即ALU输出、DM输出、PC8输出，那么我们可以在转发起点对这三个来源整合为一个MUX，选择信号由来源指令的控制信号决定，比如说`add`指令的转发来源MUX信号在E/M/W三级分别是：无法转发/ALU/ALU；而`jal`则为：PC8/PC8/PC8，这个信号直接从CTRL控制器输出，随着指令一起流水就行，（还记得我上面的图吗）这样FROM_E/FROM_M/FROM_W这三个MUX的输出对应的就是“最新的数据”。

当然每一个冒险输入的MUX也简化了，这样比如D级输入侧MUX只需要选择：原始数据、从E转发的数据、从M转发的数据、从W转发的数据即可。无需关注具体数据从何而来，只关注数据从哪一级来。而且由于我们阻塞优先级高于转发，所以无需担心从`from_w`等地接收到错误的信号，如果无法转发会优先阻塞直到可以转发为止。

优雅！❤

代码实现demo：
```verilog
// 数据来源
assign from_w = (ctrl_wmux == 2'b01) ? pc8_w :
                (ctrl_wmux == 2'b10) ? aluc_w :
                (ctrl_wmux == 2'b11) ? dmout_w : 32'b0;
assign from_e ...// 后略

// 数据接收
assign rd1_d =  (sel1 == 2'b01) ? from_e : // 从E级来
                (sel1 == 2'b10) ? from_m : // 从M级来
                (sel1 == 2'b11) ? from_w : // 从W级来
                tmp_rd1_d;                 // 原始数据
```

你如果每一个指令转发信号都单独编写，虽然没有`from_w`等三个信号，但是数据接收的时候就需要更多的mux来实现，逻辑也不清晰。

> 此处没有对`lui`指令的优化，如果需要的话由于其新数据实际上是从译码阶段产生的，可以直接从E寄存器后转发，因此不需要阻塞，只需要在from_e/m/w这三个信号分别加入imm16的输入即可，而数据来源的接收部分不需要修改。
>
> 某种意义上来说，从这里也能看出我这种设计的优雅之处，不需要过多修改通路也能从新增的数据来源进行转发。

#### 优化新增指令的转发

对于P6-P7，有部分新增指令与写入grf相关，需要转发：`mfhi`/`mthi`/`mflo`/`mtlo`/`mfc0`/`mtc0`

因为我本人不希望额外新增接线，而且考虑MDU和CP0作为额外的部件会导致转发变得复杂，因此决定将ALU/MDU/CP0整合为同一个部件，数据输入统一为ALU的几个输入，`mfhi`/`mflo`/`mfc0`几个指令输出均从ALU出，ALU变为时序逻辑+组合逻辑部件，内部新增`hi`/`lo`/`cp0reg[31:0]`这些寄存器：

```verilog
always @(posedge clk) begin
    if(reset) begin
        // 初始化寄存器
    end
    else begin
        case (ALUOp)
            //乘除指令，细节已隐去
            5'b01010: {hi, lo} <= $signed(A) * $signed(B);

            // mfhi/mflo
            5'b10000: hi <= A;
            5'b10001: lo <= A;

            // cp0写入
            5'b10011: //

            // eret清空exl置位
            5'b10100: `EXL <= 1'b0;
        endcase
    end
end

always @(*) begin
    case (ALUOp)
        5'b00000: res <= A + B;
        /*ALU基础组合逻辑功能部分*/
        5'b10100: //
    endcase
end
```

优雅！❤

这样做即**不需要修改冒险通路**，也不需要独立的MDU和CP0了，也碰巧实现了`eret`的清除exl功能，各种move from/to指令的读写等等，简直方便！这也是一种“高内聚”。

### CP0设计
正如上文所说，CP0已经在E级了，因此宏观PC也选E级的PC即可，我们这个时候需要审视一下能不能满足**精确异常**。

首先声明一点，我们的CP0设计的时候考虑的流程如下：
1. 第**一**个上升沿，E级流水线寄存器更新，新指令进入E级
2. 组合逻辑判断新指令是否有异常/外部是否有中断，并且根据此输出`req`信号
3. 第**二**个上升沿**之前**，（根据req）PC更新为`0x4180`
4. 第**二**个上升沿，各个其他部件根据`req`信号更新状态，清空E/M两级流水线，D和W不操作（保持正常功能），同时当前CP0写入CAUSE寄存器以及SR的EXL部分，并且由于E级随着`req`信号清空，由于组合逻辑，当前`req`即变为低电平，不影响后续。
5. 第**二**个上升沿，D级寄存器写入了`0x4180`对应的指令，PC变为4180的后续指令，完成进入异常处理阶段。

- 受害指令为E级，由于清空E/M两级流水线，那么D级和E级指令无法进入下一级，而第一个上升沿后位于M级和W级的指令继续执行，不受异常中断影响，符合精确异常要求
- 如果E级是`mult`等E级执行的指令，第一个上升沿`mult`进入E级触发req，但是由于第二个上升沿时候清空E和M，我们会发现`mult`无法进入M级，但是由于MDU整合进入ALU，在E级内，那么`mult`依旧会随着第二个上升沿启动，被执行。满足课程组要求的精确异常特殊情况。
- 如果`mult`在第一个上升沿的时候进入了D级，那么第二个上升沿的时候无法进入E级（被清空），不会被执行，满足课程组要求的精确异常特殊情况。

> 关于`mtc0`的精确异常，如果这条指令是受害指令的话，一定要保证它**不会**写入cp0寄存器，这样才满足精确异常要求，不管你CP0模块在M还是E级都一样。而`mult`的特殊情况，放在E级的CP0就不需要额外处理，比M级CP0方便。

由上可见完全符合中断异常约束，我们E级CP0完全没问题。而且由于所有的异常都可以在M级之前判断出来，因此也不会漏掉异常。

相比于M级的CP0还有这些好处：
- 接线少，简洁。
- 受害指令为访存的时候不需要额外对DM使能操作，因为根本不会让受害指令进入M级。
- 可以和ALU/MDU深度整合，简化冒险。

优雅！❤

## 代码上的优雅设计

这里可以参考我写的verilog优秀语法合集，[链接点我](http://cscore.buaa.edu.cn/#/discussion_area/1509/1477/posts)。

# 结语

我本人的CPU确实实现和大部分人不太一样，但是希望一些思路能够给你们一些启发，编写出更加优雅的代码，也祝你们顺利过关斩将，一路通过P7！

我的工作相比知识来说就是沧海一粟，但是我也盼望有朝一日能和大家一起继续填满知识的海洋。

> 精卫衔微木，将以填沧海。



</div>
<div class="reply-footer">
<abbr title="2024-12-05T20:29:04.781185+08:00"><time datetime="2024-12-05T20:29:04.781185+08:00">2024-12-05 20:29:04</time></abbr>
|
<span>CC BY-NC-SA 4.0</span>
<span class="reply-vote">❤️ 14</span>
</div>
</div>